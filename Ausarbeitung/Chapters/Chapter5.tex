% Chapter 5

\chapter{CA Guide Back End} % Main chapter title

\label{backend} % For referencing the chapter elsewhere, use \ref{Chapter1} 

\lhead{Chapter 5. \emph{CA Guide Back End}} % This is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------

\section{Introduction}

The CA Guide back end is meant to be used by the park or museum staff responsible for designing and optimizing the visiting experience. In contrast to the front end, the user interface can be more complex requiring an introductory training and support. Of course, the usability deserves special attention in spite of the training, as it has a major influence on the frequency a software is used, the attitude towards it and so the success of the whole product. %TODO Citation

There are two main tasks accomplished with the CA Guide back end:

\begin{itemize}
\item Modeling the outdoor or indoor site by defining areas on a map or floor plan and adding content that later will be presented on the mobile device when entering this area. Especially for indoor sites, single Bluetooth beacons with their identifying numbers and positions must be added to the plan to enable the mobile device to locate itself.
\item Analytic functions for understanding how the visitors move trough the exhibition and thus allowing to optimize it, similar to the way the behavior of website visitors is tracked and used to optimize the web presence\footnote{Of course, the privacy of the visitor has to be respected at any time. The data must only be collected anonymously and respecting all local privacy and data protection regulations.}.
\end{itemize}

%TODO In Place editing

\section{The Target Platform}

The back end user interface has to run in a standard web browser without specific plugins. This has several advantages: Users can start immediately to work with the product without installing any client. Having the project data in a cloud database, they can work on the same project from different locations using different computers without manually setting up a synchronization infrastructure. Computation expensive analytic functions can be performed directly on the database or web/application servers and only the results are transferred to the client, enabling it's usage on common hardware.

By allowing collaborative editing, the museum staff can easily be supported remotely in real time without having to be on site. 

\section{Architectural Decisions}

\subsection{The Client and Server Code Gap}
One of the main challenges developing for the web is the client/server code barrier. 

Modern web applications need to be highly responsive for providing a good user experience and thus be accepted by them. Operations like adding, editing or deleting entities have to be performed without having to do a full page reload to display some sort of HTML form and reloading the whole page again after the form was submitted to the server. This can be achieved using asynchronous calls to the server in the background, exchanging only the needed data with the server and refreshing just the needed part of the HTML DOM. Many operations like resorting a table can even be performed completely in the browser without even performing a server request.

This technique is commonly known as AJAX (Asynchronuous JavaScript and XML) and inside this acronym's phrase one can already spot the main problem. While AJAX gained popularity during the last years, it leveraged the massive usage of JavaScript, a dynamically typed scripting language originally not designed for big projects. In fact, JavaScript\footnote{In the cited interview Eich says "The name is a total lie" - it was just a marketing decision. JavaScript has been standardized later by Ecma International to ECMAScript.} was developed in 1995 by Brendan Eich in ten days for the Netscape browser, which is an extremely short time despite Eich's big experience in building languages \cite{interview-eich}. That led him to design the language to be malleable, and there are many libraries making programming in JavaScript a little "less painful", without solving the problem of lacking static types and other flaws.

So the two main problems to be solved are:

\begin{itemize}
\item Some data structures and algorithms already existing in the server code have to reprogrammed for the client running in the browser, creating redundancy with all the known problems it has
\item The standard programming language for client-side code lacks static typing and a class syntax, among others
\end{itemize}

The next subsection focuses on different solution attempts.

\subsection{Solution Attempts}

\subsubsection{Improved Javascript}

In the last years, several new scripting languages are emerging that compile to JavaScript. 

One of this languages was even integrated in the Play framework, which comes with an built in compiler for CoffeeScript \cite{coffeescript}. It is a small language that provides a nicer syntax for JavaScript, introducing even classes and inheritance, and compiles to plain JavaScript. However, it does not add any support for static typing.

Another noteworthy web-client language is TypeScript, which is maintained by Microsoft as open source \cite{typescript}. As the name implies, it adds static typing to JavaScript with type inference and similar to CoffeeScript it enhances the syntax. In contrast to CoffeeScript, it is a superset of JavaScript, meaning any JavaScript code is automatically valid TypeScript code, too. 
For using third party libraries in a typed way, a big repository with open source type definitions for 796 libraries at the time of writing \cite{typescript-repo}. By including a reference to such a type definition, the library's API can be accessed in a statically typed way.

This screenshot demonstrates a TypeScript compilation error and an inferred numeric type.
\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{typescript-idea.png}
\caption{TypeScript in IntelliJ IDEA}
\end{figure}

While these solutions, and especially TypeScript, smooth out the main flaws of JavaScript and are being adopted by a rising number of developers, they do not solve the need to create redundancy in client/server web applications. So for this work, I continued to search for a solution to both problems.

\subsubsection{Unified Programming Language for Server and Client Code}

There are several attempts to bring JavaScript on the server, and the most popular is Node.js, which was released in 2009. While there surely are some scenarios for server-side JavaScript like screen-capturing of rendered websites, in my opinion this is the wrong way of language unification. It brings the problems connected to JavaScript to the server side, where much better designed languages exist, like Scala. 

The other way around would be the perfect solution: Using a rich and well engineered language to write server and client code. So after some research I found the Scala.js project \cite{scalajs}. It was started on February 2013 by SÃ©bastien Doeraene, a member of the Scala team at LAMP (Programming Methods Laboratory at EPFL), after Martin Odersky suggested him to work on a JavaScript compiler \cite{scalajs-interview}.

Scala.js ports most parts of Scala and it's standard library to the browser, compiling Scala to JavaScript or more precisely to ECMAScript 5.1. So, among others, it is possible to use Scala collections, classes and traits, types, pattern matching and even Futures for concurrent processing. 

%TODO2 scala lib results in 32 mb ECMAScript, google compiler removing dead code <200kb, benchmarks

Beside avoiding to use ECMAScript directly, the big advantage of using Scala.js is beeing able to cross-compile parts of the same Scala code for both the server-side JVM and the browser-side ECMAScript engine. This helps reducing redundancy and is especially helpful for data transfer objects (DTO) representing entities of the respective domain, in the case of the CA Guide sites, areas and beacons, as we will see later.

On 5th February 2015, at the time of this writing and exactly two years after this project was started, the release v0.6.0 was announced on the official Scala website and the experimental flag was removed, defining Scala.js "production-ready" \cite{scalajs06}.

So I decided to try this very promising compiler for the CA Guide back end.

\section{Setting up the Development Platform}

\subsection{Project Structure, Scala and Play}

Typesafe's Play web framework %TODO see section bla
 is used as basis for developing the CA Guide back end. It is installed using the Activator tool, which acts as build tool and dependency manager.
 
The project is configured according to the "Play! application with Scala.js" skeleton \cite{playscalajs} referenced on the Scala.js homepage, splitting it up into three subprojects:

\begin{description}[leftmargin=!,labelwidth=\widthof{\bfseries editor-server}]
\item[$\bullet$ editor-server] The Play project including server side Scala code and the typical Play application structure consisting of an app folder%TODO
\item[$\bullet$ editor-client] Client only source code, the Scala.js project
\item[$\bullet$ editor-shared] Shared Scala sources, accessible from both the client and server source code
\end{description} 
 
The project was imported in IntelliJ IDEA 14 as sbt project, which worked very well without major problems. 

Using the activator command in a shell, %TODO run - start webserver and rebuild on page refreh, test command executes the tests

\subsection{Adding Reactive Couchbase as Scala Database Driver}

ReactiveCouchbase is an open-source database driver for connecting a Couchbase database to a Scala program \cite{reactivecouchbase}. Queries are performed using the elegant Scala Future paradigm, that will be discussed later in detail. For the integration with a Play application, a dedicated plugin is available.

Plugins can be added to Play by defining the name, version and if needed the repository url to the build.sbt file. This dependency has only to be added to the server project's dependencies.

\begin{lstlisting}[caption={Adding ReactiveCouchbase to Play via build.sbt},basicstyle=\tiny\ttfamily,language=c,aboveskip=15pt]
libraryDependencies += "org.reactivecouchbase" %% "reactivecouchbase-play" % "0.3"
resolvers += "ReactiveCouchbase" at "https://raw.github.com/ReactiveCouchbase/repository/master/releases"
\end{lstlisting}

To activate the plugin, a line has to be added to conf/play.plugins, where the first element defines the activation order and the second denotes the plugin.

\begin{lstlisting}[caption={Activating the plugins via play.plugins},basicstyle=\tiny\ttfamily,language=c,aboveskip=15pt]
\small\ttfamily{400:org.reactivecouchbase.play.plugins.CouchbasePlugin}
\end{lstlisting}

Now the connection to a previously installed Couchbase Server has to be configured. A Couchbase bucket named "guide-editor" was created using the database's admin console.

\begin{lstlisting}[caption={Attaching the driver to the local Couchbase Server},basicstyle=\tiny\ttfamily,language=c,aboveskip=15pt]
couchbase {
  buckets = [{
    host="127.0.0.1"
    port="8091"
    base="pools"
    bucket="guide-editor"
    user="<user>"
    pass="<pass>"
    timeout="0"
  }]
}
\end{lstlisting}

\subsection{Adding ÂµPickle as Lightweight Serialization Framework}

ÂµPickle (pronounced micro-Pickle) is a lightweight open source serialization/deserialization\footnote{serialization/deserialization is also called pickling/unpickling, explaining the framework's name} framework developed by Li Haoyi \cite{upickle}.
It works on the server side JVM as well as in the Scala.js browser part, making it's a good fit for transferring objects between the client and the server in this project. This is achieved by avoiding reflection in favor of performance, depending on nothing but the standard library on the Scala.js part.

For enabling it, a dependency has to be added to both the client and the server projects in the build.sbt file.

\begin{lstlisting}[caption={Adding a dependency to the client and server project},basicstyle=\tiny\ttfamily,language=c,aboveskip=15pt]
resolvers += "bintray/non" at "http://dl.bintray.com/non/maven"
# client
libraryDependencies += "com.lihaoyi" %%% "upickle" % "0.2.8"
# server
libraryDependencies += "com.lihaoyi" %% "upickle" % "0.2.8"
\end{lstlisting}

Note the new "\%\%\%" operator, which adds the Scala.js version to the artifact name to be retrieved, extending the regular sbt "\%\%" operator that adds the Scala version.

\subsection{Adding Bootstrap as UI Framework}

Bootstrap is a popular open source web UI library, started by two Twitter engineers in 2011 \cite{bootstrap}, providing a rich set of UI components like buttons, dropdowns, glyphs and modal dialogs in the browser. It consists primarily of cascading style-sheets (css), a font containing the glyphs for common actions and optional JavaScript extensions for programmed behavior.

After adding the bootstrap.css to Play's folder "public/css" and the glyph fonts to the "public/fonts" folder of the Play application, the components can be used by creating HTML elements assigned to the desired css classes and matching the needed structure of the respective UI component.

\subsection{Activating the Less Compiler}

Cascading style sheets are the common way to separate design and data of web sites and applications. Less is a meta language on top of css, Link
evolution step of standard css files, adding missing concepts to write more concise and better readable css-code. It was started in 2009 as open-source project by Alexis Sellier \cite{less}.

After enabling less, assets can be placed under assets/less and are automatically compiled to regular css files with the regular 'compile' command or when an automatic rebuild is triggered by a browser page refresh after changing a file.
%less as css


\section{Architecture and Design}

\subsection{Overview}

%Single page,  

\subsection{The Controller}

\subsubsection{Designing the REST HTTP Interface}

%HTTP methods
%Excerp routing file, reverse routing, single place of definition

\subsubsection{Controller Actions}


\subsection{The Model}

\subsubsection{Designing Classes to Cross-Compile}

%ClassDTO + Class, implicit conversion to Class: val site:Site = siteDTO, site.save() 

\subsubsection{Creating NoSQL Design Documents}

\subsubsection{Accessing the Database using Scala Futures}

The interface of the Reactive Couchbase Driver makes extensive use of Futures, a language feature introduced in Scala 2.10\footnote{The most recent Edition of \cite{scala-book} at the time of writing doesn't cover Scala 2.10. A more detailed description of Futures can be found in the Scala Online Documentation \cite{scala-futures}.}.

In this section the Future concept is explained using a simple query which retrieves a list of all sites stored in the guide-editor Couchbase bucket.


\subsection{The View}

\subsubsection{Play HTML Templates}

\subsubsection{Mockups}

\subsubsection{The Client code in Scala.js}

%Own MVC, the Model acts as a kind of local cache. Resorting, filtering
%Controller generates call to the REST Interface


